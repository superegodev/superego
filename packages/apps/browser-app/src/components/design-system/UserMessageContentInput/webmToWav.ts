/**
 * Converts a WebM audio Blob/ArrayBuffer to a WAV (16-bit PCM) Uint8Array.
 * Generated by ChatGPT.
 */
export async function webmToWav(
  input: ArrayBuffer,
): Promise<Uint8Array<ArrayBuffer>> {
  const arrayBuffer = input instanceof Blob ? await input.arrayBuffer() : input;

  // Decode to raw PCM with Web Audio
  const ctx = new AudioContext();
  const audioBuffer = await new Promise<AudioBuffer>((resolve, reject) =>
    ctx.decodeAudioData(arrayBuffer.slice(0), resolve, reject),
  );
  ctx.close();

  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const frameCount = audioBuffer.length;
  // 16-bit PCM
  const bytesPerSample = 2;
  const dataSize = frameCount * numChannels * bytesPerSample;

  // Prepare WAV container
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);

  // Helpers
  const writeString = (offset: number, str: string) => {
    for (let i = 0; i < str.length; i++)
      view.setUint8(offset + i, str.charCodeAt(i));
  };

  // RIFF header
  writeString(0, "RIFF");
  view.setUint32(4, 36 + dataSize, true);
  writeString(8, "WAVE");
  // fmt chunk
  writeString(12, "fmt ");
  // PCM chunk size
  view.setUint32(16, 16, true);
  // format = 1 (PCM)
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  // byteRate
  view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
  // blockAlign
  view.setUint16(32, numChannels * bytesPerSample, true);
  // bitsPerSample
  view.setUint16(34, 16, true);
  // data chunk
  writeString(36, "data");
  view.setUint32(40, dataSize, true);

  // Interleave and write PCM samples
  const channels: Float32Array[] = [];
  for (let ch = 0; ch < numChannels; ch++)
    channels.push(audioBuffer.getChannelData(ch));

  let offset = 44;
  for (let i = 0; i < frameCount; i++) {
    for (let ch = 0; ch < numChannels; ch++) {
      let s = channels[ch]![i]!;
      // clamp & convert float [-1,1] -> int16
      s = Math.max(-1, Math.min(1, s));
      const int16 = s < 0 ? s * 0x8000 : s * 0x7fff;
      view.setInt16(offset, int16, true);
      offset += 2;
    }
  }

  return new Uint8Array(buffer);
}
