// TODO: generated by AI, review
import { Id } from "@superego/shared-utils";
import { registeredDescribe as rd } from "@superego/vitest-registered";
import { describe, expect, it } from "vitest";
import type GetDependencies from "../GetDependencies.js";

export default rd<GetDependencies>("DocumentTextSearchIndex", (deps) => {
  it("upserting and searching", async () => {
    // Setup SUT
    const { dataRepositoriesManager } = deps();
    const collectionId = Id.generate.collection();
    const documentId = Id.generate.document();
    const textChunks = {
      title: ["Hello World"],
      body: ["This is a test document", "With multiple chunks"],
    };

    // Exercise
    await dataRepositoriesManager.runInSerializableTransaction(
      async (repos) => {
        await repos.documentTextSearchIndex.upsert(
          collectionId,
          documentId,
          textChunks,
        );
        return { action: "commit", returnValue: null };
      },
    );

    // Verify
    const results = await dataRepositoriesManager.runInSerializableTransaction(
      async (repos) => ({
        action: "commit",
        returnValue: await repos.documentTextSearchIndex.search(
          collectionId,
          "Hello",
        ),
      }),
    );
    expect(results).toMatchObject([{ collectionId, documentId }]);
  });

  it("upserting replaces existing text chunks", async () => {
    // Setup SUT
    const { dataRepositoriesManager } = deps();
    const collectionId = Id.generate.collection();
    const documentId = Id.generate.document();
    const originalTextChunks = {
      title: ["Original Title"],
      body: ["Original body content"],
    };
    await dataRepositoriesManager.runInSerializableTransaction(
      async (repos) => {
        await repos.documentTextSearchIndex.upsert(
          collectionId,
          documentId,
          originalTextChunks,
        );
        return { action: "commit", returnValue: null };
      },
    );

    // Exercise
    const updatedTextChunks = {
      title: ["Updated Title"],
      body: ["Updated body content"],
    };
    await dataRepositoriesManager.runInSerializableTransaction(
      async (repos) => {
        await repos.documentTextSearchIndex.upsert(
          collectionId,
          documentId,
          updatedTextChunks,
        );
        return { action: "commit", returnValue: null };
      },
    );

    // Verify - original content should not be found
    const originalResults =
      await dataRepositoriesManager.runInSerializableTransaction(
        async (repos) => ({
          action: "commit",
          returnValue: await repos.documentTextSearchIndex.search(
            collectionId,
            "Original",
          ),
        }),
      );
    expect(originalResults).toEqual([]);

    // Verify - updated content should be found
    const updatedResults =
      await dataRepositoriesManager.runInSerializableTransaction(
        async (repos) => ({
          action: "commit",
          returnValue: await repos.documentTextSearchIndex.search(
            collectionId,
            "Updated",
          ),
        }),
      );
    expect(updatedResults).toMatchObject([{ collectionId, documentId }]);
  });

  it("removing", async () => {
    // Setup SUT
    const { dataRepositoriesManager } = deps();
    const collectionId = Id.generate.collection();
    const documentId = Id.generate.document();
    const textChunks = {
      title: ["Removable content"],
    };
    await dataRepositoriesManager.runInSerializableTransaction(
      async (repos) => {
        await repos.documentTextSearchIndex.upsert(
          collectionId,
          documentId,
          textChunks,
        );
        return { action: "commit", returnValue: null };
      },
    );

    // Exercise
    await dataRepositoriesManager.runInSerializableTransaction(
      async (repos) => {
        await repos.documentTextSearchIndex.remove(collectionId, documentId);
        return { action: "commit", returnValue: null };
      },
    );

    // Verify
    const results = await dataRepositoriesManager.runInSerializableTransaction(
      async (repos) => ({
        action: "commit",
        returnValue: await repos.documentTextSearchIndex.search(
          collectionId,
          "Removable",
        ),
      }),
    );
    expect(results).toEqual([]);
  });

  describe("searching", () => {
    it("case: no matching documents => returns empty array", async () => {
      // Setup SUT
      const { dataRepositoriesManager } = deps();
      const collectionId = Id.generate.collection();

      // Exercise
      const results =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "nonexistent",
            ),
          }),
        );

      // Verify
      expect(results).toEqual([]);
    });

    it("case: multiple matching documents => returns all", async () => {
      // Setup SUT
      const { dataRepositoriesManager } = deps();
      const collectionId = Id.generate.collection();
      const documentId1 = Id.generate.document();
      const documentId2 = Id.generate.document();
      const documentId3 = Id.generate.document();
      await dataRepositoriesManager.runInSerializableTransaction(
        async (repos) => {
          await repos.documentTextSearchIndex.upsert(
            collectionId,
            documentId1,
            {
              title: ["Common keyword here"],
            },
          );
          await repos.documentTextSearchIndex.upsert(
            collectionId,
            documentId2,
            {
              body: ["Another common keyword"],
            },
          );
          await repos.documentTextSearchIndex.upsert(
            collectionId,
            documentId3,
            {
              title: ["Different content"],
            },
          );
          return { action: "commit", returnValue: null };
        },
      );

      // Exercise
      const results =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "common",
            ),
          }),
        );

      // Verify
      expect(results).toHaveLength(2);
      expect(results).toContainEqual(
        expect.objectContaining({ collectionId, documentId: documentId1 }),
      );
      expect(results).toContainEqual(
        expect.objectContaining({ collectionId, documentId: documentId2 }),
      );
    });

    it("case: search with null collectionId => searches across all collections", async () => {
      // Setup SUT
      const { dataRepositoriesManager } = deps();
      const collectionId1 = Id.generate.collection();
      const collectionId2 = Id.generate.collection();
      const documentId1 = Id.generate.document();
      const documentId2 = Id.generate.document();
      await dataRepositoriesManager.runInSerializableTransaction(
        async (repos) => {
          await repos.documentTextSearchIndex.upsert(
            collectionId1,
            documentId1,
            {
              title: ["Shared term in collection one"],
            },
          );
          await repos.documentTextSearchIndex.upsert(
            collectionId2,
            documentId2,
            {
              title: ["Shared term in collection two"],
            },
          );
          return { action: "commit", returnValue: null };
        },
      );

      // Exercise
      const results =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              null,
              "Shared",
            ),
          }),
        );

      // Verify
      expect(results).toHaveLength(2);
      expect(results).toContainEqual(
        expect.objectContaining({
          collectionId: collectionId1,
          documentId: documentId1,
        }),
      );
      expect(results).toContainEqual(
        expect.objectContaining({
          collectionId: collectionId2,
          documentId: documentId2,
        }),
      );
    });

    it("case: search with specific collectionId => only searches that collection", async () => {
      // Setup SUT
      const { dataRepositoriesManager } = deps();
      const collectionId1 = Id.generate.collection();
      const collectionId2 = Id.generate.collection();
      const documentId1 = Id.generate.document();
      const documentId2 = Id.generate.document();
      await dataRepositoriesManager.runInSerializableTransaction(
        async (repos) => {
          await repos.documentTextSearchIndex.upsert(
            collectionId1,
            documentId1,
            {
              title: ["Filtered content"],
            },
          );
          await repos.documentTextSearchIndex.upsert(
            collectionId2,
            documentId2,
            {
              title: ["Filtered content"],
            },
          );
          return { action: "commit", returnValue: null };
        },
      );

      // Exercise
      const results =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId1,
              "Filtered",
            ),
          }),
        );

      // Verify
      expect(results).toMatchObject([
        { collectionId: collectionId1, documentId: documentId1 },
      ]);
    });

    it("case: search finds content in different paths", async () => {
      // Setup SUT
      const { dataRepositoriesManager } = deps();
      const collectionId = Id.generate.collection();
      const documentId = Id.generate.document();
      await dataRepositoriesManager.runInSerializableTransaction(
        async (repos) => {
          await repos.documentTextSearchIndex.upsert(collectionId, documentId, {
            title: ["Title content"],
            body: ["Body content"],
            metadata: ["Metadata content"],
          });
          return { action: "commit", returnValue: null };
        },
      );

      // Exercise & Verify - search in title
      const titleResults =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "Title",
            ),
          }),
        );
      expect(titleResults).toMatchObject([{ collectionId, documentId }]);

      // Exercise & Verify - search in body
      const bodyResults =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "Body",
            ),
          }),
        );
      expect(bodyResults).toMatchObject([{ collectionId, documentId }]);

      // Exercise & Verify - search in metadata
      const metadataResults =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "Metadata",
            ),
          }),
        );
      expect(metadataResults).toMatchObject([{ collectionId, documentId }]);
    });

    it("case: search finds content across multiple chunks in same path", async () => {
      // Setup SUT
      const { dataRepositoriesManager } = deps();
      const collectionId = Id.generate.collection();
      const documentId = Id.generate.document();
      await dataRepositoriesManager.runInSerializableTransaction(
        async (repos) => {
          await repos.documentTextSearchIndex.upsert(collectionId, documentId, {
            paragraphs: [
              "First paragraph with unique1",
              "Second paragraph with unique2",
              "Third paragraph with unique3",
            ],
          });
          return { action: "commit", returnValue: null };
        },
      );

      // Exercise & Verify - search in first chunk
      const results1 =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "unique1",
            ),
          }),
        );
      expect(results1).toMatchObject([{ collectionId, documentId }]);

      // Exercise & Verify - search in second chunk
      const results2 =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "unique2",
            ),
          }),
        );
      expect(results2).toMatchObject([{ collectionId, documentId }]);

      // Exercise & Verify - search in third chunk
      const results3 =
        await dataRepositoriesManager.runInSerializableTransaction(
          async (repos) => ({
            action: "commit",
            returnValue: await repos.documentTextSearchIndex.search(
              collectionId,
              "unique3",
            ),
          }),
        );
      expect(results3).toMatchObject([{ collectionId, documentId }]);
    });
  });
});
